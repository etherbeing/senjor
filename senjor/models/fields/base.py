import logging
from abc import abstractmethod
from typing import TYPE_CHECKING, Any, Self, cast

import strawberry
import strawberry.types
import strawberry.types.field
from django.db import models
from django.db.models import Model as DjangoModel
from django.db.models.fields import Field as DjangoField
from django.db.models.fields.reverse_related import ManyToManyRel, ManyToOneRel
from django.utils.module_loading import import_string
from strawberry.types.base import StrawberryType

from senjor.models.fields.deferred import GQLDeferredAttribute

if TYPE_CHECKING:
    from senjor.models import Model as GQLModel


class GQLField(DjangoField):  # type: ignore[reportMissingTypeArgument]
    """
    Manage the fields inside a GraphQL ObjectType, Mutation or Subscriptions
    """

    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)
        self.instance: GQLModel
        self.model: DjangoModel
        self._senjor_field: strawberry.types.field.StrawberryField | None = None
        self.descriptor_class = GQLDeferredAttribute

    def get_model_instance(self, info: strawberry.Info):
        model_instance = getattr(info._field, "instance", None)  # type: ignore
        # TODO preprocess the instance here
        return model_instance

    def get_value(self, info: strawberry.Info):
        return getattr(self.get_model_instance(info), self.get_senjor_name())

    def get_senjor_field(
        self,
    ) -> strawberry.types.field.StrawberryField | None:
        from senjor.models.base import GQLModel

        if not self._senjor_field:
            related_model = getattr(self, "related_model", None)
            model: GQLModel | None = getattr(self, "model", None)
            auto_generated = False
            if model:
                fields = model._meta.get_fields(
                    include_parents=True, include_hidden=False
                )
                auto_generated = (
                    self not in fields
                )  # heuristic to determine if the field is autogenerated, if the model is declared by the user then is not autegenerated

            graphql_type: (
                type[list[Any] | list[StrawberryType] | StrawberryType | Any] | None
            ) = None

            if related_model:
                if issubclass(related_model, GQLModel) and not auto_generated:
                    related_senjor_field = related_model.get_senjor_field()
                    if getattr(self, "many_to_many", False):
                        graphql_type = list[related_senjor_field]
                    else:
                        graphql_type = related_senjor_field  # type: ignore
                elif issubclass(related_model, DjangoModel) and related_model._meta.pk:
                    if getattr(self, "many_to_many", False):
                        graphql_type = list[
                            self.native_to_senjor_field(
                                related_model._meta.pk
                            ).resolve.__annotations__.get("return", None)
                        ]
                    else:
                        graphql_type = self.native_to_senjor_field(
                            related_model._meta.pk
                        ).resolve.__annotations__.get("return", None)
                else:
                    raise Exception("Unknown model type")
            if (
                self.resolve.__annotations__.get("return", None) is None
            ):  # Some fields do not have a return type annotation, like the ones that are autogenerated or the M2M fields as we don't know before hand the type of the related model
                self.resolve.__annotations__.update({"return": graphql_type})

            self._senjor_field = strawberry.field(
                name=self.get_senjor_name(),
                description=self.get_senjor_description(),
                # graphql_type=graphql_type or self.resolve.__annotations__.get("return"),
            )(self.resolve)
            if not self._senjor_field:
                raise ValueError(
                    "The field could not be created, please check the resolve method"
                )
            assert (
                self.resolve.__annotations__.get("return", None) is not None
            ), "The resolve method must have a return type annotation"
            self._senjor_field.name = self.get_senjor_name()
        return self._senjor_field

    def get_senjor_description(self) -> str:
        return getattr(self, "help_text", None) or self.__doc__  # type: ignore

    def get_senjor_name(self) -> str:
        name = getattr(self, "accessor_name", getattr(self, "name", None))
        if not name:
            raise ValueError("Unmanaged state, no name could be obtained")
        return name

    @classmethod
    def native_to_senjor_field(cls, django_field: DjangoField) -> Self:
        """
        Returns the field used by senjor to represent the the django field
        """
        if isinstance(django_field, ManyToOneRel):
            field_class_name = "ForeignKey"
        elif isinstance(django_field, ManyToManyRel):
            field_class_name = "ManyToManyField"
        else:
            field_class_name = type(django_field).__name__
        senjor_field: type[Self] = import_string(f"senjor.models.{field_class_name}")
        kwargs: dict[str, Any] = {}
        if django_field.is_relation:  # type: ignore
            kwargs["to"] = django_field.model  # type: ignore
            if getattr(
                django_field, "one_to_many", getattr(django_field, "one_to_one", None)
            ):
                kwargs["on_delete"] = getattr(
                    django_field, "on_delete", models.DO_NOTHING
                )
        kwargs["name"]: str = cast(str, getattr(django_field, "field", django_field).cached_col.alias)  # type: ignore
        # field_model: models.Model | None = getattr(
        #     django_field,
        #     "model",
        #     getattr(django_field, "related_model", None),
        # )
        # if field_model:
        #     kwargs["name"] = kwargs["name"].removeprefix(
        #         field_model._meta.app_label + "_"
        #     )
        senjor_field_instance = senjor_field(**kwargs)
        logging.debug("Created a new object of type %s and value %s", cls, senjor_field)
        logging.debug(
            "The new object created has an internal object type with value %s",
            senjor_field_instance.resolve.__annotations__.get("return", None),
        )
        for item in django_field.__dict__.items():
            senjor_field_instance.__dict__.update({item[0]: item[1]})
        return senjor_field_instance

    @abstractmethod
    def resolve(self, info: strawberry.Info) -> Any:
        pass
